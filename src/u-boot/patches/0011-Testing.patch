From 37ede574427b4b904e4a6a21cb4c9634ac2d6c51 Mon Sep 17 00:00:00 2001
From: Mathias Gredal <mathiasgredal@icloud.com>
Date: Thu, 20 Feb 2025 23:26:02 +0100
Subject: [PATCH 11/11] Testing

---
 lib/wasm_ffi/wasm_net.c    |  8 +---
 lib/wasm_ffi/wasm_socket.c | 79 ++++++++++++++++++++++++--------------
 2 files changed, 52 insertions(+), 35 deletions(-)

diff --git a/lib/wasm_ffi/wasm_net.c b/lib/wasm_ffi/wasm_net.c
index 012a0178..f25f9652 100644
--- a/lib/wasm_ffi/wasm_net.c
+++ b/lib/wasm_ffi/wasm_net.c
@@ -40,7 +40,6 @@ err_t net_teardown_util(void)
 }
 
 /* FFI function implementations */
-
 m3ApiRawFunction(net_setup)
 {
     m3ApiReturnType(int32_t);
@@ -78,12 +77,7 @@ m3ApiRawFunction(net_teardown)
 {
     m3ApiReturnType(int32_t);
     err_t err = net_teardown_util();
-    if (err != ERR_OK)
-    {
-        m3ApiReturn(err);
-    }
-
-    m3ApiReturn(ERR_OK);
+    m3ApiReturn(err);
 }
 
 m3ApiRawFunction(net_rx)
diff --git a/lib/wasm_ffi/wasm_socket.c b/lib/wasm_ffi/wasm_socket.c
index e7672d98..1a8d3263 100644
--- a/lib/wasm_ffi/wasm_socket.c
+++ b/lib/wasm_ffi/wasm_socket.c
@@ -45,12 +45,23 @@ static void tcp_err_callback(void *arg, err_t err)
         return;
     }
 
-    /* Free the socket */
-    err_t err_2 = net_socket_free(index);
-    if (err_2 != ERR_OK)
+    /* Mark the socket as freed */
+    switch (sock->type)
     {
-        printf("net_socket_free failed: %d\n", err_2);
+    case CONN_TCP: {
+        sock->pcb.tcp = NULL;
+        break;
+    }
+    case CONN_UDP: {
+        sock->pcb.udp = NULL;
+        break;
     }
+    default:
+        break;
+    }
+
+    /* Set the last error */
+    sock->last_error = err;
 }
 
 static err_t tcp_sent_callback(void *arg, struct tcp_pcb *pcb, u16_t len)
@@ -66,6 +77,7 @@ static err_t tcp_sent_callback(void *arg, struct tcp_pcb *pcb, u16_t len)
         return ERR_ARG;
     }
 
+    /* Update the acknowledged bytes sent */
     sock->acknowledged_bytes_sent += len;
 
     return ERR_OK;
@@ -166,12 +178,11 @@ static err_t tcp_accept_callback(void *arg, struct tcp_pcb *newpcb, err_t err)
     return ERR_OK;
 }
 
-static void udp_recv_callback(void *arg, struct udp_pcb *pcb, struct pbuf *p,
-    const ip_addr_t *addr, u16_t port)
+static void udp_recv_callback(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
 {
     int8_t index = (int8_t)(uintptr_t)arg;
 
-    printf("udp_recv_callback: index = %d, addr = %s, port = %d\n", index, ipaddr_ntoa(addr), port);
+    // printf("udp_recv_callback: index = %d, addr = %s, port = %d\n", index, ipaddr_ntoa(addr), port);
 
     /* Get the socket */
     net_socket_t *sock = net_socket_get(index);
@@ -208,7 +219,7 @@ err_t net_socket_new(enum conn_type_t conn_type)
 
     switch (conn_type)
     {
-    case CONN_TCP:
+    case CONN_TCP: {
         net_ctx.sockets[index].pcb.tcp = tcp_new_ip_type(IPADDR_TYPE_V4);
         if (!net_ctx.sockets[index].pcb.tcp)
         {
@@ -221,7 +232,8 @@ err_t net_socket_new(enum conn_type_t conn_type)
         tcp_sent(net_ctx.sockets[index].pcb.tcp, tcp_sent_callback);
         tcp_recv(net_ctx.sockets[index].pcb.tcp, tcp_recv_callback);
         break;
-    case CONN_UDP:
+    }
+    case CONN_UDP: {
         net_ctx.sockets[index].pcb.udp = udp_new_ip_type(IPADDR_TYPE_V4);
         if (!net_ctx.sockets[index].pcb.udp)
         {
@@ -231,6 +243,7 @@ err_t net_socket_new(enum conn_type_t conn_type)
         /* Set callbacks */
         udp_recv(net_ctx.sockets[index].pcb.udp, udp_recv_callback, (void *)(uintptr_t)index);
         break;
+    }
     default:
         return ERR_ARG;
     }
@@ -240,6 +253,7 @@ err_t net_socket_new(enum conn_type_t conn_type)
 
     return index;
 }
+
 net_socket_t *net_socket_get(int8_t index)
 {
     /* Return NULL if index is out of bounds */
@@ -266,30 +280,42 @@ err_t net_socket_free(int8_t index)
         return ERR_ARG;
     }
 
+    // printf("net_socket_free: index = %d\n", index);
+
+    /* Free receive buffer if any */
+    if (sock->recv_buffer)
+    {
+        pbuf_free(sock->recv_buffer);
+        sock->recv_buffer = NULL;
+    }
+
     /* Close connection */
     switch (sock->type)
     {
     case CONN_TCP: {
-        err_t err = tcp_close(sock->pcb.tcp);
-        if (err != ERR_OK)
+        if (sock->pcb.tcp != NULL)
         {
-            printf("tcp_close failed, aborting: %d\n", err);
-            tcp_abort(sock->pcb.tcp);
+            // printf("net_socket_free: closing TCP connection\n");
+            err_t err = tcp_close(sock->pcb.tcp);
+            if (err != ERR_OK)
+            {
+                // printf("tcp_close failed, aborting: %d\n", err);
+                tcp_abort(sock->pcb.tcp);
+            }
         }
         break;
     }
     case CONN_UDP: {
-        udp_remove(sock->pcb.udp);
+        if (sock->pcb.udp != NULL)
+        {
+            // printf("net_socket_free: removing UDP connection\n");
+            udp_remove(sock->pcb.udp);
+        }
         break;
     }
     default:
-        printf("net_socket_free: unknown socket type\n");
-    }
-
-    /* Free receive buffer if any */
-    if (sock->recv_buffer)
-    {
-        pbuf_free(sock->recv_buffer);
+        // printf("net_socket_free: unknown socket type\n");
+        break;
     }
 
     /* Clear socket data */
@@ -346,30 +372,28 @@ err_t net_socket_connect_poll(int8_t index)
     net_socket_t *sock = net_socket_get(index);
     if (!sock)
     {
+        // printf("net_socket_connect_poll: socket not found %d\n", index);
         return ERR_ARG;
     }
 
     /* Check if the socket is connected */
     if (sock->is_connected)
     {
+        // printf("net_socket_connect_poll: socket connected\n");
         return ERR_OK;
     }
 
     /* Check if the socket has an error */
     if (sock->last_error != ERR_OK)
     {
+        // printf("net_socket_connect_poll: socket has error\n");
         return sock->last_error;
     }
 
     /* Check if the connection has timed out */
     if (get_timer(0) - sock->connection_start_time > CONNECTION_TIMEOUT_MS)
     {
-        printf("net_socket_connect_poll: connection timed out\n");
-        err_t err = net_socket_free(index);
-        if (err != ERR_OK)
-        {
-            printf("net_socket_free failed: %d\n", err);
-        }
+        // printf("net_socket_connect_poll: connection timed out\n");
         return ERR_TIMEOUT;
     }
 
@@ -562,7 +586,6 @@ err_t net_socket_read(int8_t index, void *buffer, uint32_t length)
     return read_len;
 }
 
-
 err_t net_socket_write(int8_t index, const void *buffer, uint32_t length)
 {
     /* Get the socket */
-- 
2.39.3 (Apple Git-146)


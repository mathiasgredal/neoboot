From 0c7f392bdf921205727366ff271c920925ab6a4a Mon Sep 17 00:00:00 2001
From: Mathias Gredal <mathiasgredal@icloud.com>
Date: Sat, 8 Feb 2025 07:35:07 +0100
Subject: [PATCH 10/10] Testing

---
 cmd/wasm.c                      | 664 +-------------------------------
 configs/qemu-x86_wasm_defconfig |   1 -
 include/wasm_ffi/wasm_ffi.h     |  20 +
 include/wasm_ffi/wasm_net.h     |  44 +++
 include/wasm_ffi/wasm_socket.h  | 183 +++++++++
 include/wasm_ffi/wasm_sys.h     |  56 +++
 lib/Makefile                    |   2 +-
 lib/wasm_ffi/Makefile           |   5 +
 lib/wasm_ffi/wasm_ffi.c         |  54 +++
 lib/wasm_ffi/wasm_net.c         | 212 ++++++++++
 lib/wasm_ffi/wasm_socket.c      | 660 +++++++++++++++++++++++++++++++
 lib/wasm_ffi/wasm_sys.c         |  55 +++
 12 files changed, 1294 insertions(+), 662 deletions(-)
 create mode 100644 include/wasm_ffi/wasm_ffi.h
 create mode 100644 include/wasm_ffi/wasm_net.h
 create mode 100644 include/wasm_ffi/wasm_socket.h
 create mode 100644 include/wasm_ffi/wasm_sys.h
 create mode 100644 lib/wasm_ffi/Makefile
 create mode 100644 lib/wasm_ffi/wasm_ffi.c
 create mode 100644 lib/wasm_ffi/wasm_net.c
 create mode 100644 lib/wasm_ffi/wasm_socket.c
 create mode 100644 lib/wasm_ffi/wasm_sys.c

diff --git a/cmd/wasm.c b/cmd/wasm.c
index 45bab732..2e3ba66c 100644
--- a/cmd/wasm.c
+++ b/cmd/wasm.c
@@ -3,658 +3,15 @@
  * Copyright (C) 2025, Mathias Gredal, mathiasgredal@icloud.com.
  */
 
-#include "dm/device.h"
-#include "lwip/api.h"
-#include "lwip/err.h"
-#include "lwip/ip4_addr.h"
-#include "lwip/ip_addr.h"
-#include "lwip/netif.h"
-#include "lwip/pbuf.h"
-#include "lwip/tcp.h"
-#include "lwip/tcpbase.h"
-#include "lwip/timeouts.h"
-#include "net-common.h"
+
 #include <command.h>
 #include <fs.h>
 #include <log.h>
 #include <mapmem.h>
-#include <net-lwip.h>
-#include <stdint.h>
-#include <stdio.h>
 #include <vsprintf.h>
 #include <wasm3/wasm3.h>
+#include <wasm_ffi/wasm_ffi.h>
 
-/*
- * Macro to link a raw function into a WebAssembly (WASM) module.
- *
- * This macro wraps the `m3_LinkRawFunction` call and handles error checking.
- * It links a host function (func_ptr) into the given WASM module under the
- * "env" namespace with the specified name (func_name) and signature (sig).
- *
- * Parameters:
- *   - module:    The WASM module to link the function into.
- *   - func_name: Name of the function within the WASM module.
- *   - sig:       Function signature string (e.g., "v(*i)" for void returning functions).
- *   - func_ptr:  Pointer to the host function to be linked.
- *
- * Behavior:
- *   - If the link operation fails with a critical error, it logs the error and
- *     returns `1` to indicate failure.
- *   - It tolerates `m3Err_functionLookupFailed`, as it may arise in dynamic linking scenarios.
- */
-#define LINK_RAW_FUNCTION(module, func_name, sig, func_ptr)                                                            \
-    do                                                                                                                 \
-    {                                                                                                                  \
-        /* Attempt to link the raw function */                                                                         \
-        M3Result result = m3_LinkRawFunction(module, "env", func_name, sig, func_ptr);                                 \
-                                                                                                                       \
-        /* Handle errors from the linking process */                                                                   \
-        if (result != m3Err_none && result != m3Err_functionLookupFailed)                                              \
-        {                                                                                                              \
-            log_err("Error linking function '%s': %s\n", func_name, result);                                           \
-            return 1;                                                                                                  \
-        }                                                                                                              \
-    } while (0)
-
-/*
- * Print a string from the WebAssembly (WASM) environment.
- *
- * This function retrieves a memory pointer and size from the WASM runtime,
- * validates the memory range, and then prints the string to the console.
- * It ensures safe access to the provided memory.
- *
- * Arguments:
- *   - i_ptr: Pointer to the string in WASM memory.
- *   - i_size: Size of the string (number of bytes).
- *
- * Behavior:
- *   - The function validates the memory pointer and size to prevent out-of-bounds access.
- *   - The string is printed to the console using the specified size.
- *
- * Returns:
- *   - Success if the string is printed successfully.
- *   - An error if the memory validation fails.
- */
-m3ApiRawFunction(env_print)
-{
-    /* Retrieve the pointer to the string */
-    m3ApiGetArgMem(void *, i_ptr);
-
-    /* Retrieve the size of the string */
-    m3ApiGetArg(int32_t, i_size);
-
-    /* Validate that the memory range [i_ptr, i_ptr + i_size) is accessible */
-    m3ApiCheckMem(i_ptr, i_size);
-
-    /* Print the string to the console */
-    printf("%.*s", i_size, (char *)i_ptr);
-
-    /* Indicate successful execution */
-    m3ApiSuccess();
-}
-
-/*
- * Check if a key has been pressed and retrieve its value.
- *
- * This function checks for pending input from the console. If a key is
- * available, it reads and returns the key as a 32-bit integer. If no key
- * has been pressed, it returns `-1` to indicate the absence of input.
- *
- * Returns:
- *   - Key value (int32_t) if a key is pressed.
- *   - `-1` if no key is available.
- */
-m3ApiRawFunction(env_key_pressed)
-{
-    m3ApiReturnType(int32_t); // Declare the return type as a 32-bit integer
-
-    /* Check if a character is available in the input buffer */
-    if (tstc())
-    {
-        /* Retrieve the key from the input buffer */
-        int32_t key = getchar();
-
-        /* Return the key value */
-        m3ApiReturn(key);
-    }
-
-    /* Return -1 if no key is pressed */
-    m3ApiReturn(-1);
-}
-
-/*
- * Retrieve the current system time in milliseconds.
- *
- * This function utilizes the `get_timer()` API to obtain the current
- * timer value, measured relative to system start or reset. The result
- * is returned as a 64-bit integer, ensuring compatibility with large
- * time values.
- */
-m3ApiRawFunction(env_now)
-{
-    m3ApiReturnType(int64_t); // Declare the return type as a 64-bit integer
-
-    /* Fetch the current timer value in milliseconds (relative to '0') */
-    int64_t now = get_timer(0);
-
-    /* Return the retrieved time */
-    m3ApiReturn(now);
-}
-
-/* Current network interface */
-struct netif *current_netif = NULL;
-
-/*
- * Maximum number of network sockets that can be tracked simultaneously.
- */
-#define MAX_NETWORK_SOCKETS 64
-
-/* Timeout for a connection attempt in milliseconds */
-#define CONNECTION_TIMEOUT_MS 4000
-
-/*
- * Structure to track the state of a network socket.
- */
-typedef struct NetworkSocket
-{
-    struct tcp_pcb *pcb;            // TCP protocol control block associated with the event
-    bool is_connected;              // Flag indicating whether the socket is connected
-    uint64_t connection_start_time; // Time when the connection was established
-    err_t err;                      // Error code (if any) for the socket
-    uint32_t bytes_sent;            // Number of sent bytes
-    uint32_t bytes_sent_acked;      // Number of sent bytes acknowledged
-    struct pbuf *recv_buffer;       // Receive buffer
-    uint32_t recv_bytes;            // Number of received bytes
-} NetworkSocket;
-
-/*
- * Array to store active network sockets.
- */
-static NetworkSocket network_sockets[MAX_NETWORK_SOCKETS];
-
-static void tcp_err_callback(void *arg, err_t err)
-{
-    printf("tcp_err_callback: %d\n", err);
-    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
-    {
-        if (network_sockets[i].pcb == (struct tcp_pcb *)arg)
-        {
-            network_sockets[i].err = err;
-        }
-    }
-}
-
-static err_t tcp_sent_callback(void *arg, struct tcp_pcb *pcb, u16_t len)
-{
-    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
-    {
-        if (network_sockets[i].pcb != pcb)
-            continue;
-
-        network_sockets[i].bytes_sent_acked += len;
-        break;
-    }
-
-    return ERR_OK;
-}
-
-static err_t tcp_recv_callback(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
-{
-    printf("tcp_recv_callback: %d\n", err);
-    if (p != NULL)
-    {
-        printf("tcp_recv_callback: p->len=%d\n", p->len);
-    }
-    
-    if (err != ERR_OK)
-    {
-        printf("tcp_recv_callback error: %d\n", err);
-        return err;
-    }
-
-    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
-    {
-        if (network_sockets[i].pcb != (struct tcp_pcb *)arg)
-            continue;
-
-        if (network_sockets[i].recv_buffer != NULL)
-        {
-            pbuf_cat(network_sockets[i].recv_buffer, p);
-        }
-        else
-        {
-            network_sockets[i].recv_buffer = p;
-        }
-
-        break;
-    }
-
-    return ERR_OK;
-}
-
-static void teardown_network(void)
-{
-    if (current_netif != NULL)
-    {
-        net_lwip_remove_netif(current_netif);
-        current_netif = NULL;
-    }
-}
-
-static err_t get_socket_connection_error(uint64_t socket)
-{
-
-    if (socket == 0)
-    {
-        return ERR_ARG;
-    }
-
-    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
-    {
-        if (network_sockets[i].pcb != (struct tcp_pcb *)socket)
-            continue;
-
-        if (network_sockets[i].is_connected == false)
-        {
-            return ERR_CONN;
-        }
-
-        if (network_sockets[i].err != ERR_OK)
-        {
-            return network_sockets[i].err;
-        }
-
-        return ERR_OK;
-    }
-
-    return ERR_VAL;
-}
-
-/*
- * Setup the network environment and initialize the network interface.
- * This function ensures that the network is properly configured before use.
- */
-m3ApiRawFunction(env_setup_network)
-{
-    m3ApiReturnType(int32_t); // Declare the return type as 32-bit integer
-    int32_t ret = 0;          // Default return value indicating success
-
-    /* Reset the network state */
-    teardown_network();
-
-    /* Set the current Ethernet device */
-    eth_set_current();
-
-    /* Retrieve the current Ethernet device */
-    struct udevice *udev = eth_get_dev();
-    if (!udev)
-    {
-        /* If no valid device is found, return an error */
-        m3ApiReturn(-1);
-    }
-
-    /* Create a new network interface for the device */
-    current_netif = net_lwip_new_netif(udev);
-    if (current_netif == NULL)
-    {
-        /* If network interface creation fails, return an error */
-        m3ApiReturn(-1);
-    }
-
-    /* Return success */
-    m3ApiReturn(ret);
-}
-
-m3ApiRawFunction(env_teardown_network)
-{
-    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
-    {
-        if (network_sockets[i].pcb == NULL)
-            continue;
-
-        if (network_sockets[i].pcb->state != CLOSED)
-            tcp_abort(network_sockets[i].pcb);
-        
-        if (network_sockets[i].recv_buffer != NULL)
-            pbuf_free(network_sockets[i].recv_buffer);
-
-        network_sockets[i] = (NetworkSocket){0};
-    }
-
-    teardown_network();
-    m3ApiSuccess();
-}
-
-m3ApiRawFunction(env_lwip_rx)
-{
-    m3ApiReturnType(int32_t); // Declare the return type as 32-bit integer
-
-    if (current_netif == NULL)
-        m3ApiReturn(-1);
-
-    int result = net_lwip_rx(eth_get_dev(), current_netif);
-    sys_check_timeouts();
-    m3ApiReturn(result);
-}
-
-/*
- * Create a new TCP socket.
- * This function initializes a new TCP protocol control block (PCB) and returns
- * a handle to the newly created socket. If the socket cannot be created, a
- * zero value is returned.
- */
-m3ApiRawFunction(env_socket_create)
-{
-    m3ApiReturnType(uint64_t); // Declare the return type as 64-bit unsigned integer
-
-    if (current_netif == NULL)
-        m3ApiReturn(0);
-
-    /* Attempt to create a new TCP PCB */
-    struct tcp_pcb *socket = tcp_new();
-
-    if (socket != NULL)
-    {
-        tcp_arg(socket, socket);
-        tcp_err(socket, tcp_err_callback);
-        tcp_sent(socket, tcp_sent_callback);
-        tcp_recv(socket, tcp_recv_callback);
-    }
-
-    /* Return the handle to the newly created socket */
-    m3ApiReturn((uint64_t)socket);
-}
-
-/*
- * Close a TCP socket.
- * This function attempts to close the specified TCP socket. If the socket cannot
- * be closed, an error code is returned. On success, zero is returned.
- */
-m3ApiRawFunction(env_socket_close)
-{
-    m3ApiReturnType(int32_t);      // Declare the return type as 32-bit integer
-    m3ApiGetArg(uint64_t, socket); // Retrieve the socket handle from the arguments
-
-    /* Iterate through the network sockets array to find the matching socket */
-    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
-    {
-        if (network_sockets[i].pcb != (struct tcp_pcb *)socket)
-            continue;
-
-        if (network_sockets[i].recv_buffer != NULL)
-        {
-            pbuf_free(network_sockets[i].recv_buffer);
-            network_sockets[i].recv_buffer = NULL;
-        }
-
-        /* Clear the socket state */
-        network_sockets[i] = (NetworkSocket){0};
-        break;
-    }
-
-    /* Attempt to close the specified socket */
-    err_t err = tcp_close((struct tcp_pcb *)socket);
-
-    /* Verify if the socket was successfully closed */
-    if (err != ERR_OK)
-    {
-        /* Return an error code if the socket could not be closed */
-        m3ApiReturn(err);
-    }
-
-    /* Return success */
-    m3ApiReturn(0);
-}
-
-/*
- * Callback function invoked when a TCP connection attempt completes.
- */
-static err_t tcp_connect_callback(void *arg, struct tcp_pcb *pcb, err_t error)
-{
-    printf("tcp_connect_callback: %d\n", error);
-    /* Iterate through the network sockets array to find the matching PCB */
-    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
-    {
-        if (network_sockets[i].pcb == arg)
-        {
-            /* Update the sockets with the result of the connection attempt */
-            network_sockets[i].is_connected = (error == ERR_OK);
-            network_sockets[i].err = error;
-            break;
-        }
-    }
-
-    return ERR_OK;
-}
-
-/*
- * Connect a TCP socket to a remote address and port.
- * This function initiates a TCP connection to the specified address and port.
- * The result of the connection attempt can be checked using env_socket_poll.
- */
-m3ApiRawFunction(env_socket_connect)
-{
-    m3ApiReturnType(int32_t); // Declare the return type as 32-bit integer
-    m3ApiGetArg(uint64_t, socket);
-    m3ApiGetArg(uint32_t, addr); //  Retrieve the IP address from big endian to network byte order
-    m3ApiGetArg(uint32_t, port); // Retrieve the port number from the arguments
-
-    /* Find an available slot in the network I/O events array */
-    bool slot_found = false;
-    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
-    {
-        if (network_sockets[i].pcb != NULL)
-            continue;
-
-        /* Ensure the socket is not already being tracked */
-        if (network_sockets[i].pcb == (struct tcp_pcb *)socket)
-            m3ApiReturn(ERR_VAL);
-
-        /* Assign the socket to the slot */
-        network_sockets[i].pcb = (struct tcp_pcb *)socket;
-        network_sockets[i].is_connected = false;
-        network_sockets[i].connection_start_time = get_timer(0);
-        network_sockets[i].err = ERR_OK;
-        slot_found = true;
-        break;
-    }
-
-    /* Return an error if no slot is available */
-    if (!slot_found)
-    {
-        m3ApiReturn(ERR_MEM);
-    }
-
-    /* Attempt to establish the TCP connection */
-    ip_addr_t ip_addr = {.addr = addr};
-    err_t error = tcp_connect((struct tcp_pcb *)socket, &ip_addr, port, tcp_connect_callback);
-
-    /* Return an error if the connection attempt fails immediately */
-    if (error != ERR_OK)
-    {
-        m3ApiReturn(error);
-    }
-
-    /* Return success to indicate the connection attempt is in progress */
-    m3ApiReturn(0);
-}
-
-/*
- * Check the status of a TCP socket.
- */
-m3ApiRawFunction(env_socket_check_connection)
-{
-    m3ApiReturnType(int32_t);      // Declare the return type as 32-bit integer
-    m3ApiGetArg(uint64_t, socket); // Retrieve the socket handle from the arguments
-
-    /* Iterate through the network sockets array to find the matching socket */
-    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
-    {
-        if (network_sockets[i].pcb != (struct tcp_pcb *)socket)
-            continue;
-
-        /* Return the result if the connection attempt has completed */
-        if (network_sockets[i].is_connected)
-        {
-            m3ApiReturn(ERR_OK);
-        }
-
-        /* Return the error code if the connection attempt failed */
-        if (network_sockets[i].err != ERR_OK)
-            m3ApiReturn(network_sockets[i].err);
-
-        /* Return the error code if the connection attempt timed out */
-        if (get_timer(0) - network_sockets[i].connection_start_time > CONNECTION_TIMEOUT_MS)
-            m3ApiReturn(ERR_TIMEOUT);
-
-        /* Return a special code to indicate the operation is still in progress */
-        m3ApiReturn(ERR_INPROGRESS);
-    }
-
-    /* Return an error if the socket is not being tracked */
-    m3ApiReturn(ERR_VAL);
-}
-
-m3ApiRawFunction(env_max_sockets)
-{
-    m3ApiReturnType(int32_t);
-    m3ApiReturn(MAX_NETWORK_SOCKETS);
-}
-
-m3ApiRawFunction(env_used_sockets)
-{
-    m3ApiReturnType(int32_t);
-    int num_sockets = 0;
-    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
-    {
-        if (network_sockets[i].pcb != NULL)
-        {
-            num_sockets++;
-        }
-    }
-
-    m3ApiReturn(num_sockets);
-}
-
-m3ApiRawFunction(env_socket_write)
-{
-    m3ApiReturnType(int32_t);
-    m3ApiGetArg(uint64_t, socket);
-    m3ApiGetArgMem(void *, buf);
-    m3ApiGetArg(uint32_t, len);
-    m3ApiCheckMem(buf, len);
-
-    err_t socket_err = get_socket_connection_error(socket);
-
-    if (socket_err != ERR_OK)
-    {
-        m3ApiReturn(socket_err);
-    }
-
-    uint16_t available_sndbuf = tcp_sndbuf((struct tcp_pcb *)socket);
-    if (len > available_sndbuf)
-    {
-        m3ApiReturn(ERR_MEM);
-    }
-
-    err_t err = tcp_write((struct tcp_pcb *)socket, (void *)buf, len, TCP_WRITE_FLAG_COPY);
-    if (err != ERR_OK)
-    {
-        m3ApiReturn(err);
-    }
-
-    err = tcp_output((struct tcp_pcb *)socket);
-    if (err != ERR_OK)
-    {
-        m3ApiReturn(err);
-    }
-
-    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
-    {
-        if (network_sockets[i].pcb == (struct tcp_pcb *)socket)
-        {
-            network_sockets[i].bytes_sent += len;
-            break;
-        }
-    }
-
-    m3ApiReturn(ERR_OK);
-}
-
-m3ApiRawFunction(env_socket_all_writes_acked)
-{
-    m3ApiReturnType(int32_t);
-    m3ApiGetArg(uint64_t, socket);
-    struct tcp_pcb *pcb = (struct tcp_pcb *)socket;
-
-    err_t socket_err = get_socket_connection_error(socket);
-
-    if (socket_err != ERR_OK)
-    {
-        m3ApiReturn(socket_err);
-    }
-
-    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
-    {
-        if (network_sockets[i].pcb == pcb)
-        {
-            bool sent_all = network_sockets[i].bytes_sent == network_sockets[i].bytes_sent_acked;
-            if (sent_all)
-            {
-                m3ApiReturn(ERR_OK);
-            }
-            else
-            {
-                m3ApiReturn(ERR_WOULDBLOCK);
-            }
-        }
-    }
-
-    m3ApiReturn(ERR_VAL);
-}
-
-m3ApiRawFunction(env_socket_read)
-{
-    m3ApiReturnType(int32_t);
-    m3ApiGetArg(uint64_t, socket);
-    m3ApiGetArgMem(void *, buf);
-    m3ApiGetArg(uint32_t, len);
-
-    err_t socket_err = get_socket_connection_error(socket);
-
-    if (socket_err != ERR_OK)
-    {
-        m3ApiReturn(socket_err);
-    }
-
-    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
-    {
-        if (network_sockets[i].pcb != (struct tcp_pcb *)socket)
-        {
-            continue;
-        }
-        
-        struct pbuf *p = network_sockets[i].recv_buffer;
-        if (p == NULL)
-        {
-            m3ApiReturn(ERR_WOULDBLOCK);
-        }
-
-        uint16_t read_len = pbuf_copy_partial(p, buf, len, network_sockets[i].recv_bytes);
-        network_sockets[i].recv_bytes += read_len;
-
-        if (network_sockets[i].recv_bytes == p->tot_len)
-        {
-            pbuf_free(p);
-            network_sockets[i].recv_buffer = NULL;
-            network_sockets[i].recv_bytes = 0;
-        }
-
-        m3ApiReturn(read_len);
-    }
-
-    m3ApiReturn(ERR_VAL);
-}
 
 /*
  * Execute a WebAssembly (WASM) program.
@@ -731,21 +88,8 @@ static int do_wasm(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[]
     }
 
     /* Link host functions required by the WASM module */
-    LINK_RAW_FUNCTION(module, "env_print", "v(*i)", &env_print);
-    LINK_RAW_FUNCTION(module, "env_key_pressed", "i()", &env_key_pressed);
-    LINK_RAW_FUNCTION(module, "env_now", "I()", &env_now);
-    LINK_RAW_FUNCTION(module, "env_setup_network", "i()", &env_setup_network);
-    LINK_RAW_FUNCTION(module, "env_teardown_network", "v()", &env_teardown_network);
-    LINK_RAW_FUNCTION(module, "env_lwip_rx", "i()", &env_lwip_rx);
-    LINK_RAW_FUNCTION(module, "env_socket_create", "I()", &env_socket_create);
-    LINK_RAW_FUNCTION(module, "env_socket_close", "i(I)", &env_socket_close);
-    LINK_RAW_FUNCTION(module, "env_socket_connect", "i(Iii)", &env_socket_connect);
-    LINK_RAW_FUNCTION(module, "env_socket_check_connection", "i(I)", &env_socket_check_connection);
-    LINK_RAW_FUNCTION(module, "env_max_sockets", "I()", &env_max_sockets);
-    LINK_RAW_FUNCTION(module, "env_used_sockets", "I()", &env_used_sockets);
-    LINK_RAW_FUNCTION(module, "env_socket_write", "i(I*i)", &env_socket_write);
-    LINK_RAW_FUNCTION(module, "env_socket_all_writes_acked", "i(I)", &env_socket_all_writes_acked);
-    LINK_RAW_FUNCTION(module, "env_socket_read", "i(I*i)", &env_socket_read);
+    wasm_ffi_link_all(module);
+
 
     /* Locate the "main" function within the WASM module */
     IM3Function function = NULL;
diff --git a/configs/qemu-x86_wasm_defconfig b/configs/qemu-x86_wasm_defconfig
index e811f083..a53cfa21 100644
--- a/configs/qemu-x86_wasm_defconfig
+++ b/configs/qemu-x86_wasm_defconfig
@@ -1,7 +1,6 @@
 #include <configs/qemu-x86_defconfig>
 
 CONFIG_WASM=y
-
 CONFIG_BOOTCOMMAND="setenv serverip 10.0.2.2; setenv ipaddr 10.0.2.15; setenv netmask 255.255.255.0; tftpboot $loadaddr main.wasm; dhcp; wasm $loadaddr $filesize" 
 CONFIG_SYS_MALLOC_LEN=0x10000000
 SYS_MALLOC_CLEAR_ON_INIT=n
\ No newline at end of file
diff --git a/include/wasm_ffi/wasm_ffi.h b/include/wasm_ffi/wasm_ffi.h
new file mode 100644
index 00000000..355ea352
--- /dev/null
+++ b/include/wasm_ffi/wasm_ffi.h
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2025, Mathias Gredal, mathiasgredal@icloud.com.
+ */
+
+#ifndef __WASM_FFI_H__
+#define __WASM_FFI_H__
+
+#include <wasm3/wasm3.h>
+
+/**
+ * wasm_ffi_link_all() - Link all functions in the WASM module.
+ *
+ * @module:   WASM module
+ * @return:   true if all functions were linked successfully, false otherwise
+ */
+bool wasm_ffi_link_all(IM3Module module);
+
+
+#endif /* __WASM_FFI_H__ */
diff --git a/include/wasm_ffi/wasm_net.h b/include/wasm_ffi/wasm_net.h
new file mode 100644
index 00000000..66461706
--- /dev/null
+++ b/include/wasm_ffi/wasm_net.h
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2025, Mathias Gredal, mathiasgredal@icloud.com.
+ */
+
+#ifndef __WASM_NET_H__
+#define __WASM_NET_H__
+
+#include <wasm3/wasm3.h>
+#include <wasm_ffi/wasm_socket.h>
+
+/**
+ * net_setup() - setup the network environment and initialize
+ * the network interface.
+ *
+ * This function ensures that the network is properly configured before use.
+ */
+m3ApiRawFunction(net_setup);
+
+/**
+ * net_teardown() - teardown the network environment and release the network interface.
+ */
+m3ApiRawFunction(net_teardown);
+
+/**
+ * net_rx() - receive and process incoming packets from the network interface.
+ */
+m3ApiRawFunction(net_rx);
+
+/* Bindings to all functions in wasm_socket.h */
+m3ApiRawFunction(net_socket_new_tcp_ffi);
+m3ApiRawFunction(net_socket_new_udp_ffi);
+m3ApiRawFunction(net_socket_free_ffi);
+m3ApiRawFunction(net_socket_connect_ffi);
+m3ApiRawFunction(net_socket_connect_poll_ffi);
+m3ApiRawFunction(net_socket_bind_ffi);
+m3ApiRawFunction(net_socket_listen_ffi);
+m3ApiRawFunction(net_socket_accept_ffi);
+m3ApiRawFunction(net_socket_accept_poll_ffi);
+m3ApiRawFunction(net_socket_read_ffi);
+m3ApiRawFunction(net_socket_write_ffi);
+m3ApiRawFunction(net_socket_write_poll_ffi);
+
+#endif /* __WASM_NET_H__ */
diff --git a/include/wasm_ffi/wasm_socket.h b/include/wasm_ffi/wasm_socket.h
new file mode 100644
index 00000000..bff18984
--- /dev/null
+++ b/include/wasm_ffi/wasm_socket.h
@@ -0,0 +1,183 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2025, Mathias Gredal, mathiasgredal@icloud.com.
+ */
+
+#ifndef __WASM_SOCKET_H__
+#define __WASM_SOCKET_H__
+
+#include <limits.h>
+#include <linux/types.h>
+#include <lwip/api.h>
+#include <lwip/err.h>
+
+/* Bitfield type for tracking active connections */
+typedef uint64_t net_bitfield_t;
+
+/* Maximum number of network sockets based on bitfield size */
+#define MAX_NETWORK_SOCKETS (sizeof(net_bitfield_t) * CHAR_BIT)
+
+/* Timeout for a connection attempt in milliseconds */
+#define CONNECTION_TIMEOUT_MS 4000
+
+enum conn_type_t
+{
+    CONN_TCP = 0x10,
+    CONN_UDP = 0x20,
+    CONN_RAW = 0x30
+};
+
+/* Forward declaration of struct net_socket_t */
+typedef struct net_socket_t net_socket_t;
+
+/*
+ * struct net_socket_t - structure to hold network socket data.
+ *
+ * @type:                The type of the network socket (TCP, UDP, etc.).
+ * @pcb:                 Pointer to the protocol control block (PCB) union, which can hold different PCB types (TCP,
+ * UDP, etc.).
+ * @is_connected:        Boolean flag indicating whether the socket is currently connected.
+ * @connection_start_time: Timestamp (in milliseconds) when a connection attempt was initiated.
+ * @last_error:          The last error encountered by this socket.
+ * @total_bytes_sent:    The total number of bytes sent on this socket.
+ * @acknowledged_bytes_sent: The number of bytes sent that have been acknowledged by the remote peer.
+ * @recv_buffer:         Pointer to the pbuf chain used as the receive buffer for this socket.
+ * @recv_bytes:          The number of bytes currently available in the receive buffer.
+ * @listener:            For server sockets, pointer to the listening socket.
+ */
+struct net_socket_t
+{
+    enum conn_type_t type;
+    union {
+        struct ip_pcb *ip;
+        struct tcp_pcb *tcp;
+        struct udp_pcb *udp;
+        struct raw_pcb *raw;
+    } pcb;
+    bool is_connected;
+    uint64_t connection_start_time;
+    err_t last_error;
+    uint32_t total_bytes_sent;
+    uint32_t acknowledged_bytes_sent;
+    struct pbuf *recv_buffer;
+    uint32_t recv_bytes;
+    net_socket_t *listener;
+};
+
+/*
+ * struct net_context_t - structure to hold network context data.
+ *
+ * @sockets: array of network sockets
+ * @active_connection_bitfield: bitfield to track active connections
+ */
+typedef struct
+{
+    net_socket_t sockets[MAX_NETWORK_SOCKETS];
+    net_bitfield_t active_connection_bitfield;
+} net_context_t;
+
+/**
+ * net_socket_new() - create a new network socket.
+ *
+ * @return: error code or socket index
+ */
+err_t net_socket_new(enum conn_type_t conn_type);
+
+/**
+ * net_socket_get() - get a network socket by index.
+ *
+ * @index: index of the socket to get
+ * @return: pointer to the socket
+ */
+net_socket_t *net_socket_get(int8_t index);
+
+/**
+ * net_socket_free() - free a network socket.
+ *
+ * @index: index of the socket to free
+ * @return: error code
+ */
+err_t net_socket_free(int8_t index);
+
+/**
+ * net_socket_connect() - connect a network socket to a remote host.
+ *
+ * @index: index of the socket to connect
+ * @ip: IP address of the remote host
+ * @port: port of the remote host
+ * @return: error code
+ */
+err_t net_socket_connect(int8_t index, uint32_t ip, uint16_t port);
+
+/**
+ * net_socket_connect_poll() - poll a network socket to check if it is connected.
+ *
+ * @index: index of the socket to poll
+ * @return: error code
+ */
+err_t net_socket_connect_poll(int8_t index);
+
+/**
+ * net_socket_bind() - bind a network socket to a local host.
+ *
+ * @index: index of the socket to bind
+ * @ip: IP address of the local host
+ * @port: port of the local host
+ * @return: error code
+ */
+err_t net_socket_bind(int8_t index, uint32_t ip, uint16_t port);
+
+/**
+ * net_socket_listen() - listen for incoming connections on a socket.
+ *
+ * @index: index of the socket to listen on
+ * @backlog: backlog for the socket
+ * @return: error code
+ */
+err_t net_socket_listen(int8_t index, uint16_t backlog);
+
+/**
+ * net_socket_accept() - start accepting an incoming connection on a socket.
+ *
+ * @index: index of the socket to accept on
+ * @return: error code
+ */
+err_t net_socket_accept(int8_t index);
+
+/**
+ * net_socket_accept_poll() - claim an incoming connection on a socket which has initiated an accept.
+ *
+ * @index: index of the socket to claim
+ * @return: error code
+ */
+err_t net_socket_accept_poll(int8_t index);
+
+/**
+ * net_socket_read() - read data from a network socket.
+ *
+ * @index: index of the socket to read from
+ * @buffer: buffer to read the data into
+ * @length: length of the data to read
+ * @return: error code
+ */
+err_t net_socket_read(int8_t index, void *buffer, uint32_t length);
+
+/**
+ * net_socket_write() - write data to a network socket.
+ *
+ * @index: index of the socket to write to
+ * @buffer: buffer to write the data from
+ * @length: length of the data to write
+ * @return: error code
+ */
+err_t net_socket_write(int8_t index, const void *buffer, uint32_t length);
+
+/**
+ * net_socket_write_poll() - poll a socket to check if all writes have been acknowledged.
+ *
+ * @index: index of the socket to poll
+ * @return: error code
+ */
+err_t net_socket_write_poll(int8_t index);
+
+#endif /* __WASM_SOCKET_H__ */
\ No newline at end of file
diff --git a/include/wasm_ffi/wasm_sys.h b/include/wasm_ffi/wasm_sys.h
new file mode 100644
index 00000000..8f13c4f5
--- /dev/null
+++ b/include/wasm_ffi/wasm_sys.h
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2025, Mathias Gredal, mathiasgredal@icloud.com.
+ */
+
+#ifndef __WASM_SYS_H__
+#define __WASM_SYS_H__
+
+#include <wasm3/wasm3.h>
+
+/*
+ * Print a string from the WebAssembly (WASM) environment.
+ *
+ * This function retrieves a memory pointer and size from the WASM runtime,
+ * validates the memory range, and then prints the string to the console.
+ * It ensures safe access to the provided memory.
+ *
+ * Arguments:
+ *   - i_ptr: Pointer to the string in WASM memory.
+ *   - i_size: Size of the string (number of bytes).
+ *
+ * Behavior:
+ *   - The function validates the memory pointer and size to prevent
+ * out-of-bounds access.
+ *   - The string is printed to the console using the specified size.
+ *
+ * Returns:
+ *   - Success if the string is printed successfully.
+ *   - An error if the memory validation fails.
+ */
+m3ApiRawFunction(env_print);
+
+/*
+ * Check if a key has been pressed and retrieve its value.
+ *
+ * This function checks for pending input from the console. If a key is
+ * available, it reads and returns the key as a 32-bit integer. If no key
+ * has been pressed, it returns `-1` to indicate the absence of input.
+ *
+ * Returns:
+ *   - Key value (int32_t) if a key is pressed.
+ *   - `-1` if no key is available.
+ */
+m3ApiRawFunction(env_key_pressed);
+
+/*
+ * Retrieve the current system time in milliseconds.
+ *
+ * This function utilizes the `get_timer()` API to obtain the current
+ * timer value, measured relative to system start or reset. The result
+ * is returned as a 64-bit integer, ensuring compatibility with large
+ * time values.
+ */
+m3ApiRawFunction(env_now);
+
+#endif /* __WASM_SYS_H__ */
diff --git a/lib/Makefile b/lib/Makefile
index 572ebdfd..47d086fb 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -102,7 +102,7 @@ obj-$(CONFIG_$(XPL_)MBEDTLS_LIB) += mbedtls/
 obj-$(CONFIG_NET_LWIP) += lwip/
 
 obj-$(CONFIG_WASM) += wasm3/
-
+obj-$(CONFIG_WASM) += wasm_ffi/
 ifdef CONFIG_XPL_BUILD
 obj-$(CONFIG_SPL_YMODEM_SUPPORT) += crc16-ccitt.o
 obj-$(CONFIG_$(PHASE_)HASH) += crc16-ccitt.o
diff --git a/lib/wasm_ffi/Makefile b/lib/wasm_ffi/Makefile
new file mode 100644
index 00000000..e50f90ee
--- /dev/null
+++ b/lib/wasm_ffi/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# Copyright (C) 2025, Mathias Gredal, mathiasgredal@icloud.com.
+
+obj-y += wasm_ffi.o wasm_sys.o wasm_net.o wasm_socket.o
\ No newline at end of file
diff --git a/lib/wasm_ffi/wasm_ffi.c b/lib/wasm_ffi/wasm_ffi.c
new file mode 100644
index 00000000..c8686b3a
--- /dev/null
+++ b/lib/wasm_ffi/wasm_ffi.c
@@ -0,0 +1,54 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2025, Mathias Gredal, mathiasgredal@icloud.com.
+ */
+
+#include <log.h>
+#include <wasm_ffi/wasm_ffi.h>
+#include <wasm_ffi/wasm_net.h>
+#include <wasm_ffi/wasm_sys.h>
+
+/*
+ * Macro to link a raw function into a WebAssembly (WASM) module.
+ */
+#define LINK_RAW_FUNCTION(module, func_name, sig, func_ptr)                                                            \
+    do                                                                                                                 \
+    {                                                                                                                  \
+        /* Attempt to link the raw function */                                                                         \
+        M3Result result = m3_LinkRawFunction(module, "env", func_name, sig, func_ptr);                                 \
+                                                                                                                       \
+        /* Handle errors from the linking process */                                                                   \
+        if (result != m3Err_none && result != m3Err_functionLookupFailed)                                              \
+        {                                                                                                              \
+            log_err("Error linking function '%s': %s\n", func_name, result);                                           \
+            return 1;                                                                                                  \
+        }                                                                                                              \
+    } while (0)
+
+bool wasm_ffi_link_all(IM3Module module)
+{
+    /* Sys functions */
+    LINK_RAW_FUNCTION(module, "env_print", "v(*i)", &env_print);
+    LINK_RAW_FUNCTION(module, "env_key_pressed", "i()", &env_key_pressed);
+    LINK_RAW_FUNCTION(module, "env_now", "I()", &env_now);
+
+    /* Network functions */
+    LINK_RAW_FUNCTION(module, "env_net_setup", "i()", &net_setup);
+    LINK_RAW_FUNCTION(module, "env_net_teardown", "i()", &net_teardown);
+    LINK_RAW_FUNCTION(module, "env_net_rx", "i()", &net_rx);
+
+    /* Socket functions */
+    LINK_RAW_FUNCTION(module, "env_net_socket_new_tcp", "i()", &net_socket_new_tcp_ffi);
+    LINK_RAW_FUNCTION(module, "env_net_socket_new_udp", "i()", &net_socket_new_udp_ffi);
+    LINK_RAW_FUNCTION(module, "env_net_socket_free", "i(i)", &net_socket_free_ffi);
+    LINK_RAW_FUNCTION(module, "env_net_socket_connect", "i(iii)", &net_socket_connect_ffi);
+    LINK_RAW_FUNCTION(module, "env_net_socket_connect_poll", "i(i)", &net_socket_connect_poll_ffi);
+    LINK_RAW_FUNCTION(module, "env_net_socket_bind", "i(iii)", &net_socket_bind_ffi);
+    LINK_RAW_FUNCTION(module, "env_net_socket_listen", "i(ii)", &net_socket_listen_ffi);
+    LINK_RAW_FUNCTION(module, "env_net_socket_accept", "i(i)", &net_socket_accept_ffi);
+    LINK_RAW_FUNCTION(module, "env_net_socket_accept_poll", "i(i)", &net_socket_accept_poll_ffi);
+    LINK_RAW_FUNCTION(module, "env_net_socket_read", "i(i*i)", &net_socket_read_ffi);
+    LINK_RAW_FUNCTION(module, "env_net_socket_write", "i(i*i)", &net_socket_write_ffi);
+    LINK_RAW_FUNCTION(module, "env_net_socket_write_poll", "i(i)", &net_socket_write_poll_ffi);
+    return 0;
+}
\ No newline at end of file
diff --git a/lib/wasm_ffi/wasm_net.c b/lib/wasm_ffi/wasm_net.c
new file mode 100644
index 00000000..eea056ff
--- /dev/null
+++ b/lib/wasm_ffi/wasm_net.c
@@ -0,0 +1,212 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2025, Mathias Gredal, mathiasgredal@icloud.com.
+ */
+
+#include "lwip/err.h"
+#include "wasm3/wasm3.h"
+#include <stdint.h>
+#include <wasm_ffi/wasm_net.h>
+#include <wasm_ffi/wasm_socket.h>
+
+#include <lwip/timeouts.h>
+#include <lwip/tcp.h>
+#include <lwip/tcpbase.h>
+#include <net-common.h>
+#include <net-lwip.h>
+
+/* Current network interface */
+static struct netif *current_netif = NULL;
+
+/* Utility function to teardown the network interface */
+err_t net_teardown_util(void)
+{
+    /* Clean up all sockets */
+    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
+    {
+        net_socket_free(i);
+    }
+
+    /* Remove network interface */
+    if (current_netif != NULL)
+    {
+        net_lwip_remove_netif(current_netif);
+        current_netif = NULL;
+    }
+
+    return ERR_OK;
+}
+
+/* FFI function implementations */
+
+m3ApiRawFunction(net_setup)
+{
+    m3ApiReturnType(int32_t);
+    err_t err = ERR_OK;
+
+    /* Reset the network state */
+    err = net_teardown_util();
+    if (err != ERR_OK)
+    {
+        m3ApiReturn(err);
+    }
+
+    /* Set the current Ethernet device */
+    eth_set_current();
+
+    /* Retrieve the current Ethernet device */
+    struct udevice *udev = eth_get_dev();
+    if (!udev)
+    {
+        /* If no valid device is found, return an error */
+        m3ApiReturn(ERR_IF);
+    }
+
+    /* Create a new network interface for the device */
+    current_netif = net_lwip_new_netif(udev);
+    if (!current_netif)
+    {
+        m3ApiReturn(ERR_IF);
+    }
+
+    m3ApiReturn(ERR_OK);
+}
+
+m3ApiRawFunction(net_teardown)
+{
+    m3ApiReturnType(int32_t);
+    err_t err = net_teardown_util();
+    if (err != ERR_OK)
+    {
+        m3ApiReturn(err);
+    }
+
+    m3ApiReturn(ERR_OK);
+}
+
+m3ApiRawFunction(net_rx)
+{
+    m3ApiReturnType(int32_t);
+
+    /* Check if the network interface is valid */
+    if (!current_netif)
+    {
+        m3ApiReturn(ERR_IF);
+    }
+
+    /* Process any pending network events */
+    err_t err = net_lwip_rx(eth_get_dev(), current_netif);
+    if (err != ERR_OK)
+    {
+        m3ApiReturn(err);
+    }
+
+    /* Check for any expired timeouts */
+    sys_check_timeouts();
+
+    m3ApiReturn(ERR_OK);
+}
+
+/* Bindings to all functions in wasm_socket.h */
+m3ApiRawFunction(net_socket_new_tcp_ffi)
+{
+    m3ApiReturnType(int32_t);
+    err_t err = net_socket_new(CONN_TCP);
+    m3ApiReturn(err);
+}
+
+m3ApiRawFunction(net_socket_new_udp_ffi)
+{
+    m3ApiReturnType(int32_t);
+    err_t err = net_socket_new(CONN_UDP);
+    m3ApiReturn(err);
+}
+
+m3ApiRawFunction(net_socket_free_ffi)
+{
+    m3ApiReturnType(int32_t);
+    m3ApiGetArg(int32_t, index);
+    err_t err = net_socket_free(index);
+    m3ApiReturn(err);
+}
+
+m3ApiRawFunction(net_socket_connect_ffi)
+{
+    m3ApiReturnType(int32_t);
+    m3ApiGetArg(int32_t, index);
+    m3ApiGetArg(uint32_t, ip);
+    m3ApiGetArg(uint16_t, port);
+    err_t err = net_socket_connect(index, ip, port);
+    m3ApiReturn(err);
+}
+
+m3ApiRawFunction(net_socket_connect_poll_ffi)
+{
+    m3ApiReturnType(int32_t);
+    m3ApiGetArg(int32_t, index);
+    err_t err = net_socket_connect_poll(index);
+    m3ApiReturn(err);
+}
+
+m3ApiRawFunction(net_socket_bind_ffi)
+{
+    m3ApiReturnType(int32_t);
+    m3ApiGetArg(int32_t, index);
+    m3ApiGetArg(uint32_t, ip);
+    m3ApiGetArg(uint16_t, port);
+    err_t err = net_socket_bind(index, ip, port);
+    m3ApiReturn(err);
+}
+
+m3ApiRawFunction(net_socket_listen_ffi)
+{
+    m3ApiReturnType(int32_t);
+    m3ApiGetArg(int32_t, index);
+    m3ApiGetArg(uint16_t, backlog);
+    err_t err = net_socket_listen(index, backlog);
+    m3ApiReturn(err);
+}
+
+m3ApiRawFunction(net_socket_accept_ffi)
+{
+    m3ApiReturnType(int32_t);
+    m3ApiGetArg(int32_t, index);
+    err_t err = net_socket_accept(index);
+    m3ApiReturn(err);
+}
+
+m3ApiRawFunction(net_socket_accept_poll_ffi)
+{
+    m3ApiReturnType(int32_t);
+    m3ApiGetArg(int32_t, index);
+    err_t err = net_socket_accept_poll(index);
+    m3ApiReturn(err);
+}
+
+m3ApiRawFunction(net_socket_read_ffi)
+{
+    m3ApiReturnType(int32_t);
+    m3ApiGetArg(int32_t, index);
+    m3ApiGetArgMem(void *, buffer);
+    m3ApiGetArg(uint32_t, length);
+    err_t err = net_socket_read(index, buffer, length);
+    m3ApiReturn(err);
+}
+
+m3ApiRawFunction(net_socket_write_ffi)
+{
+    m3ApiReturnType(int32_t);
+    m3ApiGetArg(int32_t, index);
+    m3ApiGetArgMem(void *, buffer);
+    m3ApiGetArg(uint32_t, length);
+    err_t err = net_socket_write(index, buffer, length);
+    m3ApiReturn(err);
+}
+
+m3ApiRawFunction(net_socket_write_poll_ffi)
+{
+    m3ApiReturnType(int32_t);
+    m3ApiGetArg(int32_t, index);
+    err_t err = net_socket_write_poll(index);
+    m3ApiReturn(err);
+}
diff --git a/lib/wasm_ffi/wasm_socket.c b/lib/wasm_ffi/wasm_socket.c
new file mode 100644
index 00000000..d7364790
--- /dev/null
+++ b/lib/wasm_ffi/wasm_socket.c
@@ -0,0 +1,660 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2025, Mathias Gredal, mathiasgredal@icloud.com.
+ */
+
+#include "lwip/pbuf.h"
+#include <lwip/api.h>
+#include <lwip/err.h>
+#include <lwip/tcp.h>
+#include <lwip/udp.h>
+#include <stdio.h>
+#include <wasm_ffi/wasm_socket.h>
+
+#include <net-common.h>
+#include <net-lwip.h>
+
+/* Network context */
+static net_context_t net_ctx;
+
+/* Utility functions */
+static int32_t net_socket_find_free_slot(void)
+{
+    for (int32_t i = 0; i < MAX_NETWORK_SOCKETS; i++)
+    {
+        if (!(net_ctx.active_connection_bitfield & (1ULL << i)))
+        {
+            return i;
+        }
+    }
+
+    return -1;
+}
+
+/* LWIP callback functions */
+static void tcp_err_callback(void *arg, err_t err)
+{
+    int8_t index = (int8_t)(uintptr_t)arg;
+
+    printf("tcp_err_callback: index = %d, err = %d\n", index, err);
+
+    /* Get the socket */
+    net_socket_t *sock = net_socket_get(index);
+    if (!sock)
+    {
+        return;
+    }
+
+    /* Free the socket */
+    err_t err_2 = net_socket_free(index);
+    if (err_2 != ERR_OK)
+    {
+        printf("net_socket_free failed: %d\n", err_2);
+    }
+}
+
+static err_t tcp_sent_callback(void *arg, struct tcp_pcb *pcb, u16_t len)
+{
+    int8_t index = (int8_t)(uintptr_t)arg;
+
+    printf("tcp_sent_callback: index = %d, len = %d\n", index, len);
+
+    /* Get the socket */
+    net_socket_t *sock = net_socket_get(index);
+    if (!sock)
+    {
+        return ERR_ARG;
+    }
+
+    sock->acknowledged_bytes_sent += len;
+
+    return ERR_OK;
+}
+
+static err_t tcp_recv_callback(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
+{
+    int8_t index = (int8_t)(uintptr_t)arg;
+
+    printf("tcp_recv_callback: index = %d, err = %d\n", index, err);
+
+    /* Get the socket */
+    net_socket_t *sock = net_socket_get(index);
+    if (!sock)
+    {
+        return ERR_ARG;
+    }
+
+    /* Append the received data to the socket's receive buffer */
+    if (sock->recv_buffer != NULL)
+    {
+        pbuf_cat(sock->recv_buffer, p);
+    }
+    else
+    {
+        sock->recv_buffer = p;
+    }
+
+    return ERR_OK;
+}
+static err_t tcp_connect_callback(void *arg, struct tcp_pcb *pcb, err_t err)
+{
+    int8_t index = (int8_t)(uintptr_t)arg;
+
+    printf("tcp_connect_callback: index = %d, err = %d\n", index, err);
+
+    /* Get the socket */
+    net_socket_t *sock = net_socket_get(index);
+    if (!sock)
+    {
+        return ERR_ARG;
+    }
+
+    /* Set the socket's connection state */
+    sock->is_connected = (err == ERR_OK);
+    sock->last_error = err;
+
+    return ERR_OK;
+}
+
+static err_t tcp_accept_callback(void *arg, struct tcp_pcb *newpcb, err_t err)
+{
+    int8_t listener_index = (int8_t)(uintptr_t)arg;
+
+    printf("tcp_accept_callback: listener_index = %d, err = %d\n", listener_index, err);
+
+    /* Check if there was an error */
+    if (err != ERR_OK || !newpcb)
+    {
+        return ERR_ABRT;
+    }
+
+    /* Get the listener socket */
+    net_socket_t *listener_sock = net_socket_get(listener_index);
+    if (!listener_sock)
+    {
+        printf("tcp_accept_callback: listener_sock not found\n");
+        tcp_abort(newpcb);
+        return ERR_ABRT;
+    }
+
+    /* Get a free socket slot */
+    int8_t client_index = net_socket_find_free_slot();
+    if (client_index == -1)
+    {
+        printf("tcp_accept_callback: no free socket slot found\n");
+        tcp_abort(newpcb);
+        return ERR_ABRT;
+    }
+
+    /* Set the connection socket */
+    memset(&net_ctx.sockets[client_index], 0, sizeof(net_socket_t));
+    net_ctx.sockets[client_index].type = CONN_TCP;
+    net_ctx.sockets[client_index].pcb.tcp = newpcb;
+
+    /* Set the listener socket */
+    net_ctx.sockets[client_index].listener = &net_ctx.sockets[listener_index];
+
+    /* Set callbacks */
+    tcp_arg(net_ctx.sockets[client_index].pcb.tcp, (void *)(uintptr_t)client_index);
+    tcp_err(net_ctx.sockets[client_index].pcb.tcp, tcp_err_callback);
+    tcp_sent(net_ctx.sockets[client_index].pcb.tcp, tcp_sent_callback);
+    tcp_recv(net_ctx.sockets[client_index].pcb.tcp, tcp_recv_callback);
+
+    /* Mark the socket as active */
+    net_ctx.active_connection_bitfield |= (1ULL << client_index);
+
+    return ERR_OK;
+}
+
+static void udp_recv_callback(void *arg, struct udp_pcb *pcb, struct pbuf *p,
+    const ip_addr_t *addr, u16_t port)
+{
+    int8_t index = (int8_t)(uintptr_t)arg;
+
+    printf("udp_recv_callback: index = %d, addr = %s, port = %d\n", index, ipaddr_ntoa(addr), port);
+
+    /* Get the socket */
+    net_socket_t *sock = net_socket_get(index);
+    if (!sock)
+    {
+        return;
+    }
+
+    /* Append the received data to the socket's receive buffer if the IP and port match */
+    if (sock->recv_buffer != NULL)
+    {
+        pbuf_cat(sock->recv_buffer, p);
+    }
+    else
+    {
+        sock->recv_buffer = p;
+    }
+}
+
+err_t net_socket_new(enum conn_type_t conn_type)
+{
+    /* Find first free socket slot */
+    int8_t index = net_socket_find_free_slot();
+
+    /* Return error if no free slot is found */
+    if (index == -1)
+    {
+        return ERR_MEM;
+    }
+
+    /* Initialize socket structure */
+    memset(&net_ctx.sockets[index], 0, sizeof(net_socket_t));
+    net_ctx.sockets[index].type = conn_type;
+
+    switch (conn_type)
+    {
+    case CONN_TCP:
+        net_ctx.sockets[index].pcb.tcp = tcp_new_ip_type(IPADDR_TYPE_V4);
+        if (!net_ctx.sockets[index].pcb.tcp)
+        {
+            return ERR_MEM;
+        }
+
+        /* Set callbacks */
+        tcp_arg(net_ctx.sockets[index].pcb.tcp, (void *)(uintptr_t)index);
+        tcp_err(net_ctx.sockets[index].pcb.tcp, tcp_err_callback);
+        tcp_sent(net_ctx.sockets[index].pcb.tcp, tcp_sent_callback);
+        tcp_recv(net_ctx.sockets[index].pcb.tcp, tcp_recv_callback);
+        break;
+    case CONN_UDP:
+        net_ctx.sockets[index].pcb.udp = udp_new_ip_type(IPADDR_TYPE_V4);
+        if (!net_ctx.sockets[index].pcb.udp)
+        {
+            return ERR_MEM;
+        }
+
+        /* Set callbacks */
+        udp_recv(net_ctx.sockets[index].pcb.udp, udp_recv_callback, (void *)(uintptr_t)index);
+        break;
+    default:
+        return ERR_ARG;
+    }
+
+    /* Mark socket as active */
+    net_ctx.active_connection_bitfield |= (1ULL << index);
+
+    return index;
+}
+net_socket_t *net_socket_get(int8_t index)
+{
+    /* Return NULL if index is out of bounds */
+    if (index < 0 || index >= MAX_NETWORK_SOCKETS)
+    {
+        return NULL;
+    }
+
+    /* Return NULL if socket is not active */
+    if (!(net_ctx.active_connection_bitfield & (1ULL << index)))
+    {
+        return NULL;
+    }
+
+    return &net_ctx.sockets[index];
+}
+
+err_t net_socket_free(int8_t index)
+{
+    /* Get the socket */
+    net_socket_t *sock = net_socket_get(index);
+    if (!sock)
+    {
+        return ERR_ARG;
+    }
+
+    /* Close connection */
+    switch (sock->type)
+    {
+    case CONN_TCP: {
+        err_t err = tcp_close(sock->pcb.tcp);
+        if (err != ERR_OK)
+        {
+            printf("tcp_close failed, aborting: %d\n", err);
+            tcp_abort(sock->pcb.tcp);
+        }
+        break;
+    }
+    case CONN_UDP: {
+        udp_remove(sock->pcb.udp);
+        break;
+    }
+    default:
+        printf("net_socket_free: unknown socket type\n");
+    }
+
+    /* Free receive buffer if any */
+    if (sock->recv_buffer)
+    {
+        pbuf_free(sock->recv_buffer);
+    }
+
+    /* Clear socket data */
+    memset(sock, 0, sizeof(net_socket_t));
+
+    /* Mark socket as inactive */
+    net_ctx.active_connection_bitfield &= ~(1ULL << index);
+
+    return ERR_OK;
+}
+
+err_t net_socket_connect(int8_t index, uint32_t ip, uint16_t port)
+{
+    /* Get the socket */
+    net_socket_t *sock = net_socket_get(index);
+    if (!sock)
+    {
+        return ERR_ARG;
+    }
+
+    /* Connect the socket */
+    ip_addr_t ip_addr = {.addr = ip};
+    switch (sock->type)
+    {
+    case CONN_TCP: {
+        err_t err = tcp_connect(sock->pcb.tcp, &ip_addr, port, tcp_connect_callback);
+        if (err != ERR_OK)
+        {
+            return err;
+        }
+        break;
+    }
+    case CONN_UDP: {
+        err_t err = udp_connect(sock->pcb.udp, &ip_addr, port);
+        if (err != ERR_OK)
+        {
+            return err;
+        }
+        break;
+    }
+    default:
+        return ERR_ARG;
+    }
+
+    /* Set the socket's connection start time */
+    sock->connection_start_time = get_timer(0);
+
+    return ERR_OK;
+}
+
+err_t net_socket_connect_poll(int8_t index)
+{
+    /* Get the socket */
+    net_socket_t *sock = net_socket_get(index);
+    if (!sock)
+    {
+        return ERR_ARG;
+    }
+
+    /* Check if the socket is connected */
+    if (sock->is_connected)
+    {
+        return ERR_OK;
+    }
+
+    /* Check if the socket has an error */
+    if (sock->last_error != ERR_OK)
+    {
+        return sock->last_error;
+    }
+
+    /* Check if the connection has timed out */
+    if (get_timer(0) - sock->connection_start_time > CONNECTION_TIMEOUT_MS)
+    {
+        printf("net_socket_connect_poll: connection timed out\n");
+        err_t err = net_socket_free(index);
+        if (err != ERR_OK)
+        {
+            printf("net_socket_free failed: %d\n", err);
+        }
+        return ERR_TIMEOUT;
+    }
+
+    return ERR_WOULDBLOCK;
+}
+
+err_t net_socket_bind(int8_t index, uint32_t ip, uint16_t port)
+{
+    /* Get the socket */
+    net_socket_t *sock = net_socket_get(index);
+    if (!sock)
+    {
+        return ERR_ARG;
+    }
+
+    /* Bind the socket */
+    ip_addr_t ip_addr = {.addr = ip};
+    switch (sock->type)
+    {
+    case CONN_TCP: {
+        err_t err = tcp_bind(sock->pcb.tcp, &ip_addr, port);
+        if (err != ERR_OK)
+        {
+            return err;
+        }
+        break;
+    }
+    case CONN_UDP: {
+        err_t err = udp_bind(sock->pcb.udp, &ip_addr, port);
+        if (err != ERR_OK)
+        {
+            return err;
+        }
+        break;
+    }
+    default:
+        return ERR_ARG;
+    }
+
+    return ERR_OK;
+}
+
+err_t net_socket_listen(int8_t index, uint16_t backlog)
+{
+    /* Get the socket */
+    net_socket_t *sock = net_socket_get(index);
+    if (!sock)
+    {
+        return ERR_ARG;
+    }
+
+    /* Check if the socket is a TCP socket */
+    if (sock->type != CONN_TCP)
+    {
+        return ERR_ARG;
+    }
+
+    /* Place the socket in listening mode */
+    switch (sock->type)
+    {
+    case CONN_TCP: {
+        struct tcp_pcb *new_pcb = tcp_listen_with_backlog(sock->pcb.tcp, backlog);
+        if (!new_pcb)
+        {
+            return ERR_MEM;
+        }
+
+        /* Set the new listening socket */
+        sock->pcb.tcp = new_pcb;
+        break;
+    }
+    default:
+        return ERR_ARG;
+    }
+
+    return ERR_OK;
+}
+
+err_t net_socket_accept(int8_t index)
+{
+    /* Get the socket */
+    net_socket_t *sock = net_socket_get(index);
+    if (!sock)
+    {
+        return ERR_ARG;
+    }
+
+    /* Check if the socket is a TCP socket */
+    if (sock->type != CONN_TCP)
+    {
+        return ERR_ARG;
+    }
+
+    /* Check if the socket is in the LISTEN state */
+    if (sock->pcb.tcp->state != LISTEN)
+    {
+        return ERR_CLSD;
+    }
+
+    tcp_accept(sock->pcb.tcp, tcp_accept_callback);
+
+    return ERR_OK;
+}
+
+err_t net_socket_accept_poll(int8_t index)
+{
+    /* Get the socket */
+    net_socket_t *listen_sock = net_socket_get(index);
+    if (!listen_sock)
+    {
+        return ERR_ARG;
+    }
+
+    /* Check if the socket is a TCP socket */
+    if (listen_sock->type != CONN_TCP)
+    {
+        return ERR_ARG;
+    }
+
+    /* Check if the socket is in the LISTEN state */
+    if (listen_sock->pcb.tcp->state != LISTEN)
+    {
+        return ERR_CLSD;
+    }
+
+    /* Find the newly created accept socket */
+    net_socket_t *accept_sock = NULL;
+    int accept_sock_index = -1;
+    for (int i = 0; i < MAX_NETWORK_SOCKETS; i++)
+    {
+        if (net_ctx.sockets[i].listener == listen_sock && !net_ctx.sockets[i].is_connected)
+        {
+            accept_sock = &net_ctx.sockets[i];
+            accept_sock_index = i;
+            break;
+        }
+    }
+
+    /* Check if the accept socket was found */
+    if (!accept_sock)
+    {
+        return ERR_WOULDBLOCK;
+    }
+
+    /* Set the accept socket */
+    net_ctx.sockets[accept_sock_index].is_connected = true;
+
+    return accept_sock_index;
+}
+
+err_t net_socket_read(int8_t index, void *buffer, uint32_t length)
+{
+    /* Get the socket */
+    net_socket_t *sock = net_socket_get(index);
+    if (!sock)
+    {
+        return ERR_ARG;
+    }
+
+    /* Check if the socket is connected */
+    if (sock->type == CONN_TCP && !sock->is_connected)
+    {
+        return ERR_CLSD;
+    }
+
+    /* Check if there's data available to read */
+    struct pbuf *p = sock->recv_buffer;
+    if (!p)
+    {
+        return ERR_WOULDBLOCK;
+    }
+
+    /* Copy data from receive buffer to user buffer */
+    uint16_t read_len = pbuf_copy_partial(p, buffer, length, sock->recv_bytes);
+    sock->recv_bytes += read_len;
+
+    /* If we've read all data, free the buffer */
+    if (sock->recv_bytes == p->tot_len)
+    {
+        pbuf_free(p);
+        sock->recv_buffer = NULL;
+        sock->recv_bytes = 0;
+    }
+
+    return read_len;
+}
+
+
+err_t net_socket_write(int8_t index, const void *buffer, uint32_t length)
+{
+    /* Get the socket */
+    net_socket_t *sock = net_socket_get(index);
+    if (!sock)
+    {
+        return ERR_ARG;
+    }
+
+    /* Send data to the socket */
+    switch (sock->type)
+    {
+    case CONN_TCP: {
+        /* Check if the socket is connected */
+        if (!sock->is_connected)
+        {
+            return ERR_CLSD;
+        }
+
+        /* Write the data to the socket */
+        err_t err = tcp_write(sock->pcb.tcp, buffer, length, TCP_WRITE_FLAG_COPY);
+        if (err != ERR_OK)
+        {
+            return err;
+        }
+
+        /* Flush the output buffer */
+        err = tcp_output(sock->pcb.tcp);
+        if (err != ERR_OK)
+        {
+            return err;
+        }
+        sock->total_bytes_sent += length;
+        break;
+    }
+    case CONN_UDP: {
+        err_t err;
+        struct pbuf *p = pbuf_alloc(PBUF_TRANSPORT, length, PBUF_RAM);
+        if (!p)
+        {
+            return ERR_MEM;
+        }
+        err = pbuf_take(p, buffer, length);
+        if (err != ERR_OK)
+        {
+            pbuf_free(p);
+            return err;
+        }
+        err = udp_send(sock->pcb.udp, p);
+        if (err != ERR_OK)
+        {
+            pbuf_free(p);
+            return err;
+        }
+        pbuf_free(p);
+        sock->total_bytes_sent += length;
+        sock->acknowledged_bytes_sent += length;
+        break;
+    }
+    default:
+        return ERR_ARG;
+    }
+
+    return ERR_OK;
+}
+
+err_t net_socket_write_poll(int8_t index)
+{
+    /* Get the socket */
+    net_socket_t *sock = net_socket_get(index);
+    if (!sock)
+    {
+        return ERR_ARG;
+    }
+
+    switch (sock->type)
+    {
+    case CONN_TCP: {
+        /* Check if the socket is connected */
+        if (!sock->is_connected)
+        {
+            return ERR_CLSD;
+        }
+
+        /* Check if all data has been acknowledged */
+        if (sock->acknowledged_bytes_sent < sock->total_bytes_sent)
+        {
+            return ERR_WOULDBLOCK;
+        }
+        break;
+    }
+    case CONN_UDP: {
+        break;
+    }
+    default:
+        return ERR_ARG;
+    }
+
+    return ERR_OK;
+}
diff --git a/lib/wasm_ffi/wasm_sys.c b/lib/wasm_ffi/wasm_sys.c
new file mode 100644
index 00000000..46f4aefc
--- /dev/null
+++ b/lib/wasm_ffi/wasm_sys.c
@@ -0,0 +1,55 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2025, Mathias Gredal, mathiasgredal@icloud.com.
+ */
+
+#include <stdio.h>
+#include <time.h>
+#include <wasm_ffi/wasm_sys.h>
+
+m3ApiRawFunction(env_print)
+{
+    /* Retrieve the pointer to the string */
+    m3ApiGetArgMem(void *, i_ptr);
+
+    /* Retrieve the size of the string */
+    m3ApiGetArg(int32_t, i_size);
+
+    /* Validate that the memory range [i_ptr, i_ptr + i_size) is accessible */
+    m3ApiCheckMem(i_ptr, i_size);
+
+    /* Print the string to the console */
+    printf("%.*s", i_size, (char *)i_ptr);
+
+    /* Indicate successful execution */
+    m3ApiSuccess();
+}
+
+m3ApiRawFunction(env_key_pressed)
+{
+    m3ApiReturnType(int32_t); // Declare the return type as a 32-bit integer
+
+    /* Check if a character is available in the input buffer */
+    if (tstc())
+    {
+        /* Retrieve the key from the input buffer */
+        int32_t key = getchar();
+
+        /* Return the key value */
+        m3ApiReturn(key);
+    }
+
+    /* Return -1 if no key is pressed */
+    m3ApiReturn(-1);
+}
+
+m3ApiRawFunction(env_now)
+{
+    m3ApiReturnType(int64_t); // Declare the return type as a 64-bit integer
+
+    /* Fetch the current timer value in milliseconds (relative to '0') */
+    int64_t now = get_timer(0);
+
+    /* Return the retrieved time */
+    m3ApiReturn(now);
+}
\ No newline at end of file
-- 
2.39.3 (Apple Git-146)

